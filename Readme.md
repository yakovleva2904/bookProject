чебный проект

Критерии проверки и качества кода

Б1. Код соответствует техническому заданию проекта.
Все обязательные пункты технического задания выполнены.


Б2. При выполнении кода не возникает необработанных ошибок.
При открытии диалогов, загрузки данных и работе с сайтом не возникает ошибок, программа не ломается и не зависает.



Б3. Названия переменных, параметров, свойств и методов начинаются со строчной буквы и записываются в нотации lowerCamelCase.
Исключение составляют перечисления, они записываются в нотации CamelCase.


Б4. В качестве имён переменных и свойств используются английские существительные.
Сокращения в словах запрещены. Сокращённые названия переменных можно использовать только, если такое название широко распространено. Допустимые сокращения:

xhr, для объектов XMLHttpRequest;
evt для объектов Event и его производных (MouseEvent, KeyboardEvent и подобные);
ctx для контекста канваса;
i, j, k, l, для счётчика в цикле, j для счётчика во вложенном цикле и так далее по алфавиту;
если циклов два и более, то можно не переиспользовать переменную i;
cb для единственного колбэка в параметрах функции;
img для именования переменной, содержащей ссылку на тег <img>;
src для именования переменной, хранящей адрес, например изображения;
err для обозначения объекта ошибок в конструкциях try...catch или колбэках.
Допустимо именовать переменные-предикаты — флаги или функции, которые возвращают булево значение — по схеме «is + признак». Например:

const loading = true; // правильно
const isLoading = true; // тоже правильно

function checkValueToNull(value) { // правильно
  return value === null;
}

function isNull(value) { // тоже правильно
  return value === null;
}

Б5. Массивы названы существительными во множественном числе.
Неправильно:

const age = [12, 40, 22, 7];
const name = ['Иван', 'Петр', 'Мария', 'Алексей'];

const wizard = {
  name: 'Гендальф',
  friend: ['Саурон', 'Фродо', 'Бильбо']
};
Правильно:

const ages = [12, 40, 22, 7];
const names = ['Иван', 'Петр', 'Мария', 'Алексей'];

const wizard = {
  name: 'Гендальф',
  friends: ['Саурон', 'Фродо', 'Бильбо']
};
Обратите внимание, что слово data — это множественное число от слова datum, поэтому его использование в качестве имени переменной для массива корректно.


Б6. Название функции или метода содержит глагол.
Название функции или метода должно быть глаголом и соответствовать действию, которое выполняет функция или метод. Например, можно использовать глагол get для функций и методов, которые что-то возвращают.

Исключения:

Функции конструкторы.
Функции обработчики или колбэки.
Неправильно:

const action = function (names) {
  names.forEach((name) => {
    console.log(name);
  });
};

const wizard = {
  name: 'Гендальф',
  action() {
    console.log('Стреляю файрболлом!');
  }
};

const randomNumber = () => Math.random();
Правильно:

const printNames = function (names) {
  names.forEach((name) => {
    console.log(name);
  });
};

const wizard = {
  name: 'Гендальф',
  shoot() {
    console.log('Стреляю файрболлом!');
  }
};

const getRandomNumber = () => Math.random();

Б7. Названия констант (постоянных значений) написаны прописными (заглавными) буквами.
Слова разделяются подчёркиваниями (UPPER_SNAKE_CASE), например:

const MAX_HEIGHT = 400;
const EARTH_RADIUS = 6370;

Б8. Название классов, конструкторов и перечислений начинается с заглавной буквы. В названии используются английские существительные. Значения перечислений объявлены как константы.
Неправильно:

// Функция-конструктор
const wizard = function (name, age) {
  this.name = name;
  this.age = age;
};

// Функция
const Fly = function (coordinate) {
  console.log(`Смотрите, я лечу вон туда ${coordinate}!`);
};

// Перечисление
const statusCodes = {
  ok: 200,
  notFound: 404,
  badRequest: 400,
};

// Перечисление
const STATUS_CODE = {
  Ok: 200,
  NotFound: 404,
  BadRequest: 400,
};
Правильно:

// Функция-конструктор
const Wizard = function (name, age) {
  this.name = name;
  this.age = age;
};

// Функция
const fly = function (coordinate) {
  console.log(`Смотрите, я лечу вон туда ${coordinate}!`);
};

// Перечисление
const StatusCode = {
  OK: 200,
  NOT_FOUND: 404,
  BAD_REQUEST: 400,
};
Названия функций, не являющихся конструкторами, должны начинаться со строчной буквы.

Обратите внимание, что не все объекты в коде проекта должны быть перечислениями. Например, допускается использование объектов в качестве словарей:

const priceTypeToRange = {
  low: 'до 200 ₽',
  medium: 'от 200 ₽ до 500 ₽',
  high: 'от 500 ₽',
};


Б9. Используются обязательные блоки кода.
В любых конструкциях, где подразумевается использование блока кода (фигурных скобок), таких как for, while, if, switch, function — блок кода используется обязательно, даже если инструкция состоит из одной строчки.

Неправильно:

let isEven = true;
if (x % 2 === 1) isEven = false;
Правильно:

let isEven = true;
if (x % 2 === 1) {
  isEven = false;
}
Исключения составляют однострочные стрелочные функции, которые можно использовать без обязательных блоков кода:

const checkedCheckboxes = checkboxes.filter((checkbox) => checkbox.checked);

Б10. Список констант идёт перед основным кодом.
Все константы выносятся в начало модуля. Перечисления, как набор констант, также выносятся.


Б11. Код соответствует стилю оформления, принятому на проекте.
Не возникает ошибок при проверке проекта ESLint.

МусорСвернуть все

Б12. В итоговом коде проекта находятся только те файлы, которые были на момент создания репозитория, которые были получены в патчах и файлы, созданные по заданию.
В коде проекта нет файлов, модулей и частей кода, которые не используются, включая закомментированные участки кода.


Б13. Версии используемых зависимостей зафиксированы в package.json.
В списках зависимостей в файле package.json указаны точные версии используемых пакетов. Версия обязательно должна быть указана. Не допускается использование ^, * и ~.


Б14. В коде нет заранее недостижимых участков кода.
Например:

Невыполнимые условия:
if (false) {
  console.log('This will not happen anyway!');
}
Операции после выхода из функции:
(function () {
  return;
  console.log('This will not happen!');
})();
КорректностьСвернуть все

Б15. Константы нигде в коде не переопределяются.
Константы используются только для чтения, и никогда не переопределяются на всем промежутке жизни программы.


Б16. Включён строгий режим.
В коде запрещены небезопасные конструкции. Код работает в строгом режиме. В начале js-файлов установлена директива 'use strict'; или используются ES-модули, которые по умолчанию работают в строгом режиме.


Б17. Используются строгие сравнения вместо нестрогих.
Вместо операторов нестрогого сравнения == и !=, используются операторы строгого сравнения ===, !==. Таблицы истинности для JavaScript.

Неправильно:

const foo = '';
const bar = [];
if (foo == bar) {
  destroy(world);
}
Правильно:

const foo = '';
const bar = [];
if (foo === bar) {
  destroy(world);
}

Б18. В коде не используются зарезервированные слова в качестве имён переменных и свойств.
В названия переменных и свойств не включаются операторы и ключевые слова зарезервированные для будущих версий языка (например, class, extends). Список всех зарезервированных слов можно найти на MDN.



Б19. Все файлы JS представляют собой отдельные модули ES2015, а название модуля соответствует его содержимому и записано строчными (маленькими) буквами, слова разделены дефисами.
Экспорт и импорт значений производится при помощи ключевых слов export и import. Сохранение в глобальную область видимости значений не допускается.

Разные логические части кода вынесены в отдельные файлы модулей. Имя файла модуля должно соответствовать его содержимому. Для того, чтобы избежать конфликтов имён в разных операционных системах, лучше применять наименее конфликтный способ именования файлов — строчными (маленькими) буквами через дефис. Например, если модуль называется GameView, то имя файла модуля должно быть game-view.js.


Б20. Модули не экспортируют изменяющиеся переменные.
Модуль не должен экспортировать переменную, значение которой может измениться в будущем.

Неправильно:

export let latestResult;
Правильно:

export const latestResult = loadLatestResult();


Б21. Код является кроссбраузерным и не вызывает ошибок в разных браузерах и разных операционных системах.
При проверке этого критерия, необходимо удостовериться в правильной работе и отсутствии сообщений об ошибках в выполняемых скриптах только в последних версиях браузеров: Chrome, Firefox, Safari, Microsoft Edge (на движке Blink).

Обратите внимание, Safari плохо поддерживает работу с валидацией. Например, не показывает ошибку, если при отправке формы не введены данные в поле с атрибутом required. Поэтому небольшие ошибки, связанные с валидацией только в Safari, можно проигнорировать.

Важно: на Windows и Linux тестировать в Safari не нужно.


Б22. Нельзя пользоваться глобальной переменной event.
Неправильно:

const block = document.querySelector('.test');

const onBlockClick = function () {
  event.target.innerText = 'You really need event';
};

block.addEventListener('click', onBlockClick);
Правильно:

const block = document.querySelector('.test');

const onBlockClick = function (evt) {
  evt.target.innerText = 'You really need event';
};

block.addEventListener('click', onBlockClick);
ОптимальностьСвернуть все

Б23. Своевременный выход из цикла: цикл не работает дольше чем нужно.
Неправильно:

apartments.forEach((apartment, index) => {
  if (index < 3) {
    render(apartment);
  }
});
Правильно:

for (let i = 0; i < Math.min(apartments.length, 3); i++) {
  render(apartments[i]);
}

Б24. Количество вызовов циклов минимизировано.
Если задачу можно решить за один проход по циклу, вместо нескольких она должна быть решена за один.

Неправильно:

const wizardNames = data.map(function (item) {
  return item.wizard;
}).map(function (wizard) {
  return wizard.name;
});
Правильно:

const wizardNames = data.map(function (item) {
  return item.wizard.name;
});

Б25. Множественные DOM-операции производятся на элементах, которые не добавлены в DOM.
Например, наполнение скопированного из шаблона элемента данными или генерация разметки целиком средствами JavaScript:

const cardList = document.querySelector('.card-list');
const cardTemplate = document.querySelector('#card-template').content;
const card = cardTemplate.cloneNode(true);
const message = document.createElement('p');

card.querySelector('.title').textContent = 'Hello, world!';
message.textContent = 'How are you?';

card.querySelector('.message').appendChild(message);
cardList.appendChild(card);
БезопасностьСвернуть все

Б26. Обработчики событий добавляются и удаляются своевременно.
Обработчики событий для виджетов добавляются только в момент появления виджета на странице и удаляются в момент их исчезновения.

Защита от memory-leak
Количество обработчиков, подвешенных на глобальную область видимости, не должно возрастать. Например, если подвешивается обработчик, который следит за перемещением курсора по экрану, то он должен подвешиваться и отвешиваться в нужный момент. Случай, когда обработчик на document только подвешивается, может свидетельствовать о проблеме бесконечного создания обработчиков и потенциальной утечке памяти.

Защита от неправильного поведения интерфейса Например, на странице может существовать попап, который скрывается по ESC. Лучше для него гасить обработчик, если он не показан, потому что он может каким-то образом ломать поведение сайта — останавливать распространение, отменять поведение по умолчанию и так далее. Поэтому поведение должно быть явным — если в этот момент времени обработчики не нужны, их нужно удалить. Явное и предсказуемое поведение.


Б27. Для вставки пользовательских строк (имён, фамилий и так далее) использован textContent.
Защита от XSS-атак, а также изменения исходных данных, запутывание пользователя и прочее.

Неправильно: через innerHTML вставляются данные, которые невозможно полностью контролировать. Это может быть пользовательский ввод, который может содержать XSS.

const listItem = listItemTemplate.cloneNode(true);
listItem.querySelector('.title').innerHTML = user.fullName;
Правильно: через innerHTML вставляется код, который был создан программистом, поэтому сделать его вредоносным невозможно. innerHTML используется для лаконичного создания сложной разметки, но при этом в разметку не вставляются никакие внешние данные.

const listItemTemplate = '<li class="amenity"><i></i><a href="#"></a></li>';
list.innerHTML = listItemTemplate;
